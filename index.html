<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Coloring Game</title>
  <style>
    body { display:flex; margin:0; font-family:sans-serif; }
    #sidebar { width:200px; padding:10px; background:#f0f0f0; }
    #canvas-wrap { flex:1; }
    canvas { border:1px solid #ccc; cursor: crosshair; }
    .tool, .color, .btn { margin:5px; padding:5px; cursor:pointer; display:inline-block; }
    .active { border:2px solid red !important; }
    .color { width:24px; height:24px; }
  </style>
</head>
<body>
  <div id="sidebar">
    <h4>Pages</h4><div id="pages"></div>
    <h4>Tools</h4>
    <div id="tools">
      <div class="tool" data-tool="brush">Brush</div>
      <div class="tool" data-tool="crayon">Crayon</div>
      <div class="tool" data-tool="bucket">Bucket</div>
      <div class="tool" data-tool="eraser">Eraser</div>
    </div>
    <h4>Colors</h4><div id="colors"></div>
    <div>
      <button id="undo" class="btn">Undo</button>
      <button id="redo" class="btn">Redo</button>
      <button id="save" class="btn">Save</button>
    </div>
  </div>
  <div id="canvas-wrap"><canvas id="drawCanvas" width="600" height="600"></canvas></div>

  <script>
  // Your image URLs, ensure they support CORS
  const drawings = [
    'https://i.postimg.cc/XYZ/mermaid.png',
    // ... other URLs
  ];

  const canvas = document.getElementById('drawCanvas');
  const ctx = canvas.getContext('2d');
  let tool='brush', color='black', drawing=false;
  const img = new Image();
  img.crossOrigin = 'anonymous';

  const undoStack=[], redoStack=[];
  const toolsEl = document.getElementById('tools');
  const colorsEl = document.getElementById('colors');
  const pagesEl = document.getElementById('pages');

  // UI setup
  drawings.forEach((src,i)=>{
    const btn=document.createElement('button');
    btn.textContent='Page '+(i+1);
    btn.onclick=()=>loadPage(i,true);
    pagesEl.appendChild(btn);
  });

  ['brush','crayon','bucket','eraser'].forEach(t=>{
    const d = document.querySelector(`.tool[data-tool="${t}"]`);
    d.onclick=()=>{ tool=t; updateActive(); };
  });
  ['black','red','green','blue','orange'].forEach(c=>{
    const d=document.createElement('div');
    d.className='color';
    d.style.background=c;
    d.onclick=()=>{ color=c; updateActive(); };
    colorsEl.appendChild(d);
  });

  document.getElementById('undo').onclick=undo;
  document.getElementById('redo').onclick=redo;
  document.getElementById('save').onclick=()=>{ 
    const a=document.createElement('a');
    a.download='coloring.png';
    a.href=canvas.toDataURL();
    a.click();
  };

  updateActive();
  loadPage(0,false);

  canvas.onmousedown=e=>{
    drawing=true;
    const {x,y}=getXY(e);
    if(tool==='bucket'){
      const imgd = ctx.getImageData(0,0,canvas.width,canvas.height);
      const rgba = hexToRgba(color);
      floodfill(imgd.data, x, y, rgba, 128, imgd.width, imgd.height);
      ctx.putImageData(imgd,0,0);
      pushUndo();
      drawing=false;
    } else {
      ctx.beginPath();
      ctx.moveTo(x,y);
    }
  };
  canvas.onmousemove=draw;
  canvas.onmouseup=()=>{ if(drawing && tool!=='bucket'){ draw(null, true); pushUndo(); } drawing=false; };

  function draw(e,end=false){
    if(!drawing) return;
    const {x,y}=getXY(e);
    ctx.strokeStyle = tool==='eraser'?'white':color;
    ctx.lineWidth = tool==='brush'?5:(tool==='crayon'?15:20);
    ctx.globalAlpha = tool==='crayon'?0.3:1;
    ctx.lineCap = tool==='brush'?'round':'square';
    ctx.lineTo(x,y);
    ctx.stroke();
    if(end) ctx.globalAlpha=1;
  }

  function getXY(e){
    const r=canvas.getBoundingClientRect();
    return { x: e.clientX-r.left, y: e.clientY-r.top };
  }

  function updateActive(){
    document.querySelectorAll('.tool').forEach(d=>d.classList.toggle('active', d.dataset.tool===tool));
    document.querySelectorAll('.color').forEach(d=>d.classList.toggle('active', d.style.backgroundColor===color));
  }

  function loadPage(i, clearHist){
    if(clearHist){ undoStack.length=redoStack.length=0; }
    img.onload=()=>{
      ctx.fillStyle='white';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.drawImage(img,0,0,canvas.width,canvas.height);
      pushUndo();
    };
    img.src=drawings[i];
  }

  function pushUndo(){
    undoStack.push(canvas.toDataURL());
    if(undoStack.length>50) undoStack.shift();
    redoStack.length=0;
  }
  function undo(){
    if(undoStack.length<2)return;
    redoStack.push(undoStack.pop());
    restore(undoStack[undoStack.length-1]);
  }
  function redo(){
    if(!redoStack.length)return;
    const d=redoStack.pop();
    undoStack.push(d);
    restore(d);
  }
  function restore(src){
    const i=new Image();
    i.onload=()=>ctx.drawImage(i,0,0);
    i.src=src;
  }

  // Tolerance-based flood‑fill from binarymax/floodfill.js 1
  function floodfill(data, x, y, fill, tol, w, h){
    const stack = [{x,y}];
    const idx = (y*w + x)*4;
    const bc = data.slice(idx, idx+4);
    function match(px){
      return Math.abs(px[0]-bc[0])<=tol &&
             Math.abs(px[1]-bc[1])<=tol &&
             Math.abs(px[2]-bc[2])<=tol &&
             Math.abs(px[3]-bc[3])<=tol;
    }
    while(stack.length){
      const {x,y}=stack.pop();
      let nx=x;
      while(nx>=0 && match(data.slice((y*w+nx)*4,(y*w+nx)*4+4))) nx--;
      nx++;
      let spanL=false, spanR=false;
      for(let i=nx;i<w && match(data.slice((y*w+i)*4,(y*w+i)*4+4));i++){
        const pi=(y*w+i)*4;
        data[pi]=fill.r;data[pi+1]=fill.g;data[pi+2]=fill.b;data[pi+3]=fill.a;
        if(y>0){
          const upIdx=((y-1)*w+i)*4;
          if(match(data.slice(upIdx,upIdx+4))){
            if(!spanL){ stack.push({x:i,y:y-1}); spanL=true; }
          } else spanL=false;
        }
        if(y<h-1){
          const dnIdx=((y+1)*w+i)*4;
          if(match(data.slice(dnIdx,dnIdx+4))){
            if(!spanR){ stack.push({x:i,y:y+1}); spanR=true;}
          } else spanR=false;
        }
      }
    }
  }

  function hexToRgba(hex){
    const tmp=document.createElement('div');
    tmp.style.color=hex;
    document.body.appendChild(tmp);
    const [r,g,b]=getComputedStyle(tmp).color.match(/\d+/g);
    document.body.removeChild(tmp);
    return {r:+r,g:+g,b:+b,a:255};
  }
  </script>
</body>
</html>
