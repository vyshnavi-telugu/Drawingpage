<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Coloring Book with Bucket Fill</title>
<style>
  body { display: flex; margin: 0; font-family: sans-serif; }
  #sidebar { width: 250px; background: #f0f0f0; padding: 10px; }
  #canvas-wrap { flex: 1; }
  canvas { border: 1px solid #ccc; cursor: crosshair; }
  .tool, .color, .btn { margin: 5px; padding: 5px; cursor: pointer; display: inline-block; }
  .active { border: 2px solid red !important; }
  .color { width: 24px; height: 24px; border: 1px solid #333; }
</style>
</head>
<body>
  <div id="sidebar">
    <h4>Pages</h4><div id="pages"></div>
    <h4>Tools</h4>
    <div id="tools">
      <div class="tool" data-tool="bucket" title="Bucket">ðŸª£</div>
      <div class="tool" data-tool="eraser" title="Eraser">ðŸ§½</div>
    </div>
    <h4>Colors</h4><div id="colors"></div>
    <div>
      <button id="undo" class="btn">Undo</button>
      <button id="redo" class="btn">Redo</button>
      <button id="save" class="btn">Save</button>
    </div>
  </div>
  <div id="canvas-wrap">
    <canvas id="drawCanvas" width="600" height="600"></canvas>
  </div>

<script>
const drawings = [
  'https://i.postimg.cc/TPZTn08W/0f00c43f3775ba5fcce443f4885aa56e.jpg',
  'https://i.postimg.cc/JnZMxXmY/bunny-carrot-coloring-page-600nw-2414476443.jpg',
  'https://i.postimg.cc/tTxCcfd5/Barbie-6.jpg',
  'https://i.postimg.cc/pLsT5KXD/6331b296558cf1f8f7fd87cc9154f432.jpg',
  'https://i.postimg.cc/MKxKs9n7/adorable-fun-kids-coloring-page-delight-freepik-908673-3027.jpg'
];

const canvas = document.getElementById('drawCanvas');
const ctx = canvas.getContext('2d');

let tool = 'bucket', color = 'black';
let isDrawing = false;
const undoStack = [], redoStack = [];

const img = new Image();
img.crossOrigin = 'anonymous';

const pagesEl = document.getElementById('pages');
const toolsEl = document.getElementById('tools');
const colorsEl = document.getElementById('colors');

drawings.forEach((src, i) => {
  const btn = document.createElement('button');
  btn.textContent = 'Page ' + (i + 1);
  btn.onclick = () => loadPage(i, true);
  pagesEl.appendChild(btn);
});

document.querySelectorAll('.tool').forEach(el => {
  el.onclick = () => { tool = el.dataset.tool; updateUI(); };
});

['black','gray','red','orange','yellow','green','blue','purple','pink','brown','white'].forEach(c => {
  const div = document.createElement('div');
  div.className = 'color';
  div.style.background = c;
  div.onclick = () => { color = c; updateUI(); };
  colorsEl.appendChild(div);
});

document.getElementById('undo').onclick = undo;
document.getElementById('redo').onclick = redo;
document.getElementById('save').onclick = () => {
  const a = document.createElement('a');
  a.download = 'drawing.png';
  a.href = canvas.toDataURL();
  a.click();
};

updateUI();
loadPage(0, false);

canvas.onmousedown = e => {
  if (tool === 'bucket') {
    const { x, y } = getXY(e);
    const imgd = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const rgba = hexToRGBA(color);
    floodfill(imgd.data, x, y, rgba, 25, imgd.width, imgd.height);
    ctx.putImageData(imgd, 0, 0);
    pushUndo();
  } else if (tool === 'eraser') {
    ctx.globalCompositeOperation = 'destination-out';
    ctx.beginPath();
    ctx.arc(getXY(e).x, getXY(e).y, 10, 0, 2*Math.PI);
    ctx.fill();
    ctx.globalCompositeOperation = 'source-over';
    pushUndo();
  }
};

function floodfill(data, sx, sy, fill, tol, w, h) {
  const index = (sy * w + sx) * 4;
  const base = data.slice(index, index + 4);
  const colorDiff = (p1, p2) => Math.abs(p1[0]-p2[0]) + Math.abs(p1[1]-p2[1]) + Math.abs(p1[2]-p2[2]) + Math.abs(p1[3]-p2[3]);
  const isMatch = (px) => colorDiff(px, base) < tol;

  const stack = [{ x: sx, y: sy }];
  const visited = new Uint8Array(w*h);

  while (stack.length) {
    const { x, y } = stack.pop();
    if (x < 0 || x >= w || y < 0 || y >= h) continue;
    if (visited[y*w+x]) continue;
    visited[y*w+x] = 1;
    const i = (y * w + x) * 4;
    const current = data.slice(i, i+4);
    if (!isMatch(current)) continue;

    data[i]=fill.r; data[i+1]=fill.g; data[i+2]=fill.b; data[i+3]=fill.a;
    stack.push({ x:x+1, y }); stack.push({ x:x-1, y }); stack.push({ x, y:y+1 }); stack.push({ x, y:y-1 });
  }
}

function getXY(e) {
  const r = canvas.getBoundingClientRect();
  return { x: e.clientX - r.left, y: e.clientY - r.top };
}

function updateUI() {
  document.querySelectorAll('.tool').forEach(el => el.classList.toggle('active', el.dataset.tool === tool));
  document.querySelectorAll('.color').forEach(el => el.classList.toggle('active', el.style.background === color));
}

function loadPage(idx, clearHistory) {
  if (clearHistory) undoStack.length = redoStack.length = 0;
  img.onload = () => {
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
    pushUndo();
  };
  img.src = drawings[idx] + '?v=' + Date.now();
}

function pushUndo() {
  undoStack.push(canvas.toDataURL());
  if (undoStack.length > 50) undoStack.shift();
  redoStack.length = 0;
}

function undo() {
  if (undoStack.length < 2) return;
  redoStack.push(undoStack.pop());
  restore(undoStack[undoStack.length-1]);
}

function redo() {
  if (!redoStack.length) return;
  const data = redoStack.pop();
  undoStack.push(data);
  restore(data);
}

function restore(src) {
  const image = new Image();
  image.onload = () => ctx.drawImage(image, 0, 0);
  image.src = src;
}

function hexToRGBA(hex) {
  const tmp = document.createElement('div');
  tmp.style.color = hex;
  document.body.appendChild(tmp);
  const [r, g, b] = getComputedStyle(tmp).color.match(/\d+/g).map(Number);
  document.body.removeChild(tmp);
  return { r, g, b, a: 255 };
}
</script>
</body>
</html>
