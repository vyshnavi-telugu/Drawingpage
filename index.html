<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Coloring Book</title>
  <style>
    body { display:flex; margin:0; font-family:sans-serif; }
    #sidebar { width:200px; padding:10px; background:#f0f0f0; }
    #canvas-wrap { flex:1; position:relative; }
    canvas { border:1px solid #ccc; }
    .btn, .tool, .color { margin:5px; cursor:pointer; padding:5px; }
    .active { border:2px solid red; }
    .color { width:24px; height:24px; display:inline-block; }
  </style>
</head>
<body>
  <div id="sidebar">
    <h4>Pages</h4><div id="pages"></div>
    <h4>Tools</h4><div id="tools">
      <div class="tool" data-tool="brush">Brush</div>
      <div class="tool" data-tool="crayon">Crayon</div>
      <div class="tool" data-tool="bucket">Bucket</div>
      <div class="tool" data-tool="eraser">Eraser</div>
    </div>
    <h4>Colors</h4><div id="colors"></div>
    <button id="undo" class="btn">Undo</button>
    <button id="redo" class="btn">Redo</button>
    <button id="save" class="btn">Save</button>
  </div>
  <div id="canvas-wrap">
    <canvas id="drawCanvas" width="600" height="600"></canvas>
  </div>

  <script>
  const drawings = [/* your image URLs here, must allow CORS */];

  const canvas = document.getElementById('drawCanvas');
  const ctx = canvas.getContext('2d');
  let tool = 'brush', color = 'black', drawing = false;
  const img = new Image();
  const undoStack = [], redoStack = [];

  // Enable CORS for images
  img.crossOrigin = 'anonymous';

  // Populate UI
  ['brush','crayon','bucket','eraser'].forEach(t => {
    const d = document.querySelector(`.tool[data-tool="${t}"]`);
    d.onclick = () => { tool = t; updateActive(); };
  });
  ['black','red','green','blue','orange'].forEach(c => {
    const d = document.createElement('div');
    d.className='color'; d.style.background=c; d.onclick=()=>{color=c;updateActive();};
    document.getElementById('colors').appendChild(d);
  });
  document.getElementById('undo').onclick = undo;
  document.getElementById('redo').onclick = redo;
  document.getElementById('save').onclick = () => {
    const a = document.createElement('a');
    a.download = 'drawing.png';
    a.href = canvas.toDataURL();
    a.click();
  };

  drawings.forEach((src,i)=>{
    const btn=document.createElement('button');
    btn.textContent=`Page ${i+1}`;
    btn.onclick = ()=>loadPage(i,true);
    document.getElementById('pages').appendChild(btn);
  });

  function updateActive(){
    document.querySelectorAll('.tool').forEach(d=>d.classList.toggle('active', d.dataset.tool===tool));
    document.querySelectorAll('.color').forEach(d=>d.classList.toggle('active', d.style.backgroundColor===color));
  }

  function loadPage(i,clear=true){
    if(clear){undoStack.length=redoStack.length=0;}
    img.onload = () => {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      // flatten transparency
      ctx.fillStyle = '#fff';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.drawImage(img,0,0,canvas.width,canvas.height);
      pushUndo();
    };
    img.src = drawings[i];
  }

  canvas.onmousedown = e=>{
    drawing = true;
    const {x,y} = getXY(e);
    if(tool==='bucket'){
      const imgd = ctx.getImageData(0,0,canvas.width,canvas.height);
      scanlineFill(imgd, x, y, color);
      ctx.putImageData(imgd,0,0);
      pushUndo();
      drawing=false;
    } else {
      ctx.beginPath();
      ctx.moveTo(x,y);
    }
  };
  canvas.onmousemove = draw;
  canvas.onmouseup = () => { if(drawing && tool!=='bucket') { draw(undefined,true); pushUndo(); } drawing=false; };

  function draw(e,end=false){
    if(!drawing) return;
    const {x,y}=getXY(e);
    ctx.strokeStyle = tool==='eraser' ? '#fff' : color;
    ctx.lineWidth = tool==='brush' ? 5 : (tool==='crayon'?15:20);
    ctx.globalAlpha = tool==='crayon'?0.3:1;
    ctx.lineCap = tool==='brush'?'round':'square';
    ctx.lineTo(x,y); ctx.stroke();
    if(end) ctx.globalAlpha=1;
  }

  function getXY(e){
    const r=canvas.getBoundingClientRect();
    return {x:e.clientX-r.left, y:e.clientY-r.top};
  }

  function pushUndo(){
    undoStack.push(canvas.toDataURL());
    if(undoStack.length>50) undoStack.shift();
    redoStack.length=0;
  }
  function undo(){
    if(undoStack.length<2) return;
    redoStack.push(undoStack.pop());
    loadImage(undoStack[undoStack.length-1]);
  }
  function redo(){
    if(!redoStack.length) return;
    const d=redoStack.pop();
    undoStack.push(d);
    loadImage(d);
  }
  function loadImage(src){
    const i=new Image();
    i.onload=()=>ctx.drawImage(i,0,0);
    i.src = src;
  }

  // Scanline flood fill based on Lode Vandevenne’s method 1
  function scanlineFill(imgd, sx, sy, fillColor){
    const {data,width,height} = imgd;
    const target = getPixel(data, width, sx, sy);
    const fill = colorToRGBA(fillColor);
    if(equal(target,fill)) return;
    const stack = [{x:sx, y:sy}];
    while(stack.length){
      const {x,y}=stack.pop();
      let x1 = x;
      while(x1>=0 && equal(getPixel(data,width,x1,y),target)){
        x1--;
      }
      x1++;
      let reachLeft=false, reachRight=false;
      for(let i = x1; i<width && equal(getPixel(data,width,i,y),target); i++){
        setPixel(data,width,i,y,fill);
        if(!reachLeft && y>0 && equal(getPixel(data,width,i,y-1),target)){
          stack.push({x:i, y:y-1}); reachLeft=true;
        } else if(reachLeft && y>0 && !equal(getPixel(data,width,i,y-1),target)){
          reachLeft=false;
        }
        if(!reachRight && y<height-1 && equal(getPixel(data,width,i,y+1),target)){
          stack.push({x:i, y:y+1}); reachRight=true;
        } else if(reachRight && y<height-1 && !equal(getPixel(data,width,i,y+1),target)){
          reachRight=false;
        }
      }
    }
  }

  function getPixel(d,w,x,y){
    const p = 4*(y*w+x);
    return [d[p],d[p+1],d[p+2],d[p+3]];
  }
  function setPixel(d,w,x,y,col){
    const p = 4*(y*w+x);
    [d[p],d[p+1],d[p+2],d[p+3]] = col;
  }
  function equal(a,b){
    return a[0]===b[0]&&a[1]===b[1]&&a[2]===b[2]&&a[3]===b[3];
  }
  function colorToRGBA(c){
    const tmp = document.createElement('div');
    tmp.style.color = c;
    document.body.appendChild(tmp);
    const [r,g,b] = getComputedStyle(tmp).color.match(/\d+/g).map(Number);
    document.body.removeChild(tmp);
    return [r,g,b,255];
  }

  loadPage(0,false);
  </script>
</body>
</html>
